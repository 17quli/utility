 /********************************************************************************************
05/12/19 ird0sxr1 First Cut - Only tblCollect for now. tblPeriod is still being tested as it is 395+ million rows table


*********************************************************************************************/

-- Backup existing RAW START tables touched by history migration process

select count(*) as raw_count from  ${target_db=Enter the target database name here}_raw.app_tblcollect;
create table  ${target_db=Enter the target database name here}_raw.app_tblcollect_YYYYMMDD stored as parquet
as select * from  ${target_db=Enter the target database name here}_raw.app_tblcollect;
select count(*) as backup_count from  ${target_db=Enter the target database name here}_raw.app_tblcollect_YYYYMMDD;


-- Backup existing RAW TDW tables touched by history migration process

select count(*) as raw_tdw_count from  ${target_db=Enter the target database name here}_raw.tdw_tbl_collect;
create table  ${target_db=Enter the target database name here}_raw.tdw_tbl_allocation_YYYYMMDD stored as parquet
as select * from  ${target_db=Enter the target database name here}_raw.tdw_tbl_collect;
select count(*) as raw_tdw_backup_count from  ${target_db=Enter the target database name here}_raw.tdw_tbl_collect_YYYYMMDD;

-- Truncate existing RAW tables for START

truncate table  ${target_db=Enter the target database name here}_raw.app_tblcollect;
select count(*) as raw_count from  ${target_db=Enter the target database name here}_raw.app_tblcollect;

-- Truncate existing RAW tables for TDW

truncate table  ${target_db=Enter the target database name here}_raw.tdw_tbl_collect;
select count(*) as raw_tdw_count from  ${target_db=Enter the target database name here}_raw.tdw_tbl_collect;

-- Run Checks on TDW tables and START tables in SAS EG or SAS Studio (Use TDW History Load Check code: History Analysis - STEP 1). Export Results as PDF.

-- Run the Code generated by SAS DI Studio Jobs in SAS EG or SAS Studio to populate the RAW TDW tables. Save the Logs.

-- Check records in RAW TDW tables
select count(*) as raw_tdw_count from  ${target_db=Enter the target database name here}_raw.tdw_tbl_collect;


-- Using Impala commands Load data manually from RAW TDW tables into RAW START tables

INSERT INTO TABLE  ${target_db=Enter the target database name here}_raw.app_tblcollect
SELECT
CAST(FLNGCOLLECTKEY AS INT) AS flngCollectKey,
CAST(FLNGVER AS INT) AS flngVer,
CAST(FLNGVERLAST AS INT) AS flngVerLast,
CAST(FSTRCATEGORY AS VARCHAR(12)) AS fstrCategory,
CAST(FSTRCOLLECTTYPE AS VARCHAR(12)) AS fstrCollectType,
CAST(FLNGCUSTOMERKEY AS INT) AS flngCustomerKey,
CAST(FLNGCUSTOMERKEY2 AS INT) AS flngCustomerKey2,
CAST(FLNGACCOUNTKEY AS INT) AS flngAccountKey,
CAST(FINTCOLLECTPROFILENUMBER AS SMALLINT) AS fintCollectProfileNumber,
CAST(FLNGJOURNALKEY AS INT) AS flngJournalKey,
CAST(FLNGINDICATORKEY AS INT) AS flngIndicatorKey,
CAST(FLNGFOLDERKEY AS INT) AS flngFolderKey,
CAST(FCURTAX AS DECIMAL(19,4)) AS fcurTax,
CAST(FCURPENALTY AS DECIMAL(19,4)) AS fcurPenalty,
CAST(FCURINTEREST AS DECIMAL(19,4)) AS fcurInterest,
CAST(FCURBALANCE AS DECIMAL(19,4)) AS fcurBalance,
CAST(FSTRCOLLECTDISTRICTOFFICE AS VARCHAR(12)) AS fstrCollectDistrictOffice,
CAST(FSTRACCOUNTTYPE AS VARCHAR(12)) AS fstrAccountType,
CAST(FDTMWORKDATE AS TIMESTAMP) AS fdtmWorkDate,
CAST(FDTMWORKDATETIME AS TIMESTAMP) AS fdtmWorkDateTime,
CAST(FDTMCREATIONDATE AS TIMESTAMP) AS fdtmCreationDate,
CAST(FDTMCLOSEDDATE AS TIMESTAMP) AS fdtmClosedDate,
CAST(FBLNAUTOMATED AS SMALLINT) AS fblnAutomated,
CAST(FDTMNEXTSTAGE AS TIMESTAMP) AS fdtmNextStage,
CAST(FSTRSTAGEFLOW AS VARCHAR(12)) AS fstrStageFlow,
CAST(FSTRSTAGE AS VARCHAR(12)) AS fstrStage,
CAST(FSTROWNER AS VARCHAR(20)) AS fstrOwner,
CAST(FLNGRISK AS INT) AS flngRisk,
CAST(FSTRLASTCOMPLETEDSTAGE AS VARCHAR(12)) AS fstrLastCompletedStage,
CAST(FLNGTEAMKEY AS INT) AS flngTeamKey,
CAST(FLNGDOCKEY AS INT) AS flngDocKey,
CAST(FSTRWHO AS VARCHAR(20)) AS fstrWho,
CAST(EFFECTIVE_FROM AS TIMESTAMP) AS FDTMWHEN,
CAST(record_effective_timestamp AS TIMESTAMP) AS record_effective_timestamp,
CAST(record_expiry_timestamp AS TIMESTAMP) AS record_expiry_timestamp,
CAST(CURRENT_REC_FLAG AS VARCHAR(1)) AS record_active_flag,
CAST('N' AS VARCHAR(1)) AS record_deleted_flag,
CAST(insert_object_run_key AS INT) AS insert_object_run_key,
CAST(update_object_run_key AS INT) AS update_object_run_key
FROM  ${target_db=Enter the target database name here}_raw.tdw_tbl_collect;

-- Check row counts of RAW tables with TDW history loaded:

select count(*) as raw_new_count from  ${target_db=Enter the target database name here}_raw.app_tblcollect;
select count(distinct FLNGCOLLECTKEY) as distinct_keys_count FROM  ${target_db=Enter the target database name here}_raw.app_tblcollect;
select count(*) as low_date_count FROM  ${target_db=Enter the target database name here}_raw.app_tblcollect where record_effective_timestamp = '1800-01-01 00:00:00';
select count(*) as high_date_count FROM  ${target_db=Enter the target database name here}_raw.app_tblcollect where record_expiry_timestamp = '9000-12-31 00:00:00';


-- Using SAS EG or SAS Studio, run the corresponding RAW START jobs to load data to:
-- app_tblCollect.
-- This will be our first incremental job to load data on top of the data from TDW.
-- Verify jobs complete ok

-- Check the tables after Raw Incrmental load is completed
select count(*) as raw_new_count from  ${target_db=Enter the target database name here}_raw.app_tblcollect;


-- Run Checks on RAW tables in SAS EG or SAS Studio (Use TDW History Load Check code: History Analysis - STEP 2 and History Analysis - STEP 3). Export Results as PDF.


--Satish to update as required
######################################################################################################################################################################################333

--- Conduct sanity checks for individual keys

--  ${target_db=Enter the target database name here}_raw.app_tblcustomerstd
select * from  ${target_db=Enter the target database name here}_raw.app_tblcollect
where flngcollectkey=411150
order by record_effective_timestamp asc;